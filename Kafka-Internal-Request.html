<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Kafka.Internal.Request</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Kafka-Internal-Request.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">kafka-client-0.7.0.0: Low-level Haskell client library for Apache Kafka 0.7.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Kafka.Internal.Request</p></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Produce">Produce</a> = <a href="#v:Produce">Produce</a> {<ul class="subs"><li><a href="#v:produceTopic">produceTopic</a> :: !<a href="Kafka-Internal-Types.html#t:Topic">Topic</a></li><li><a href="#v:producePartition">producePartition</a> :: !<a href="Kafka-Internal-Types.html#t:Partition">Partition</a></li><li><a href="#v:produceMessages">produceMessages</a> :: [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</li></ul>}</li><li class="src short"><a href="#v:putProduceRequest">putProduceRequest</a> :: <a href="Kafka-Internal-Request.html#t:Produce">Produce</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a></li><li class="src short"><a href="#v:putMultiProduceRequest">putMultiProduceRequest</a> :: [<a href="Kafka-Internal-Request.html#t:Produce">Produce</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Fetch">Fetch</a> = <a href="#v:Fetch">Fetch</a> {<ul class="subs"><li><a href="#v:fetchTopic">fetchTopic</a> :: !<a href="Kafka-Internal-Types.html#t:Topic">Topic</a></li><li><a href="#v:fetchPartition">fetchPartition</a> :: !<a href="Kafka-Internal-Types.html#t:Partition">Partition</a></li><li><a href="#v:fetchOffset">fetchOffset</a> :: !<a href="Kafka-Internal-Types.html#t:Offset">Offset</a></li><li><a href="#v:fetchSize">fetchSize</a> :: !<a href="Kafka-Internal-Types.html#t:Size">Size</a></li></ul>}</li><li class="src short"><a href="#v:putFetchRequest">putFetchRequest</a> :: <a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a></li><li class="src short"><a href="#v:putMultiFetchRequest">putMultiFetchRequest</a> :: [<a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Offsets">Offsets</a> = <a href="#v:Offsets">Offsets</a> {<ul class="subs"><li><a href="#v:offsetsTopic">offsetsTopic</a> :: !<a href="Kafka-Internal-Types.html#t:Topic">Topic</a></li><li><a href="#v:offsetsPartition">offsetsPartition</a> :: !<a href="Kafka-Internal-Types.html#t:Partition">Partition</a></li><li><a href="#v:offsetsTime">offsetsTime</a> :: !<a href="Kafka-Internal-Types.html#t:OffsetsTime">OffsetsTime</a></li><li><a href="#v:offsetsCount">offsetsCount</a> :: !<a href="Kafka-Internal-Types.html#t:Count">Count</a></li></ul>}</li><li class="src short"><a href="#v:putOffsetsRequest">putOffsetsRequest</a> :: <a href="Kafka-Internal-Request.html#t:Offsets">Offsets</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Produce" class="def">Produce</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L53" class="link">Source</a></p><div class="doc"><p>A request to send messages down a Kafka topic-partition pair.</p><p>Produce requests do not have a corresponding response. There is no way of
 knowing in Kafka 0.7 if a message was successfully <code>Produce</code>d.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Produce" class="def">Produce</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:produceTopic" class="def">produceTopic</a> :: !<a href="Kafka-Internal-Types.html#t:Topic">Topic</a></dt><dd class="doc"><p>Kafka topic to which the messages will be sent.</p></dd><dt class="src"><a name="v:producePartition" class="def">producePartition</a> :: !<a href="Kafka-Internal-Types.html#t:Partition">Partition</a></dt><dd class="doc"><p>Partition of the topic.</p></dd><dt class="src"><a name="v:produceMessages" class="def">produceMessages</a> :: [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</dt><dd class="doc"><p>List of message payloads.</p><p>For those concerned with low-leveld details: These messages will be
 compressed using <a href="https://code.google.com/p/snappy/">Snappy</a> compression.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Produce" class="caption collapser" onclick="toggleSection('i:Produce')">Instances</p><div id="section.i:Produce" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka-Internal-Request.html#t:Produce">Produce</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka-Internal-Request.html#t:Produce">Produce</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka-Internal-Request.html#t:Produce">Produce</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:putProduceRequest" class="def">putProduceRequest</a> :: <a href="Kafka-Internal-Request.html#t:Produce">Produce</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L72" class="link">Source</a></p><div class="doc"><p><code>Put</code>s the given single <code>Produce</code> request.</p></div></div><div class="top"><p class="src"><a name="v:putMultiProduceRequest" class="def">putMultiProduceRequest</a> :: [<a href="Kafka-Internal-Request.html#t:Produce">Produce</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L77" class="link">Source</a></p><div class="doc"><p><code>Put</code>s the given <code>MultiProduce</code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Fetch" class="def">Fetch</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L85" class="link">Source</a></p><div class="doc"><p>A request to fetch messages from a particular Kafka topic-partition pair.</p><p><code><a href="Kafka.html#t:FetchResponse">FetchResponse</a></code> contains responses for this kind of request.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fetch" class="def">Fetch</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:fetchTopic" class="def">fetchTopic</a> :: !<a href="Kafka-Internal-Types.html#t:Topic">Topic</a></dt><dd class="doc"><p>Kafka topic from which messages will be fetched.</p></dd><dt class="src"><a name="v:fetchPartition" class="def">fetchPartition</a> :: !<a href="Kafka-Internal-Types.html#t:Partition">Partition</a></dt><dd class="doc"><p>Partition of the topic.</p></dd><dt class="src"><a name="v:fetchOffset" class="def">fetchOffset</a> :: !<a href="Kafka-Internal-Types.html#t:Offset">Offset</a></dt><dd class="doc"><p>Offset at which the fetch will start.</p><p>Kafka offloads the responsiblity of knowing this to the client. That
 means that if an offset is specified here that is not a real message
 start, Kafka will spit out garbage.</p><p>Use <code><a href="Kafka.html#v:offsets">offsets</a></code> to find valid offsets.</p></dd><dt class="src"><a name="v:fetchSize" class="def">fetchSize</a> :: !<a href="Kafka-Internal-Types.html#t:Size">Size</a></dt><dd class="doc"><p>Maximum size of the returned messages.</p><p>Note, this is <em>not</em> the number of messages. This is the maximum
 combined size of the returned <em>compressed</em> messages.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Fetch" class="caption collapser" onclick="toggleSection('i:Fetch')">Instances</p><div id="section.i:Fetch" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:putFetchRequest" class="def">putFetchRequest</a> :: <a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L113" class="link">Source</a></p><div class="doc"><p><code>Put</code>s the given single <code>Fetch</code> request.</p></div></div><div class="top"><p class="src"><a name="v:putMultiFetchRequest" class="def">putMultiFetchRequest</a> :: [<a href="Kafka-Internal-Request.html#t:Fetch">Fetch</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L117" class="link">Source</a></p><div class="doc"><p><code>Put</code>s the given <code>MultiFetch</code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Offsets" class="def">Offsets</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L125" class="link">Source</a></p><div class="doc"><p>A request to retrieve offset information from Kafka.</p><p>The response for this kind of request is a list of <code><a href="Kafka-Internal-Types.html#t:Offset">Offset</a></code>s.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Offsets" class="def">Offsets</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:offsetsTopic" class="def">offsetsTopic</a> :: !<a href="Kafka-Internal-Types.html#t:Topic">Topic</a></dt><dd class="doc"><p>Kafka topic from which offsets will be retrieved.</p></dd><dt class="src"><a name="v:offsetsPartition" class="def">offsetsPartition</a> :: !<a href="Kafka-Internal-Types.html#t:Partition">Partition</a></dt><dd class="doc"><p>Partition of the topic.</p></dd><dt class="src"><a name="v:offsetsTime" class="def">offsetsTime</a> :: !<a href="Kafka-Internal-Types.html#t:OffsetsTime">OffsetsTime</a></dt><dd class="doc"><p>Time around which offsets will be retrieved.</p><p>If you provide a time for this, keep in mind that the response will not
 contain the precise offset that occurred around that time. It will return
 up to <code>offsetsCount</code> offsets in descending, each being the first offset
 of every segment file for the specified partition with a modified time
 less than the specified time, and possibly a &quot;high water mark&quot; for the
 last segment of the partition (if it was modified before the specified
 time) which specifies the offset at which the next message to that
 partition will be written.</p></dd><dt class="src"><a name="v:offsetsCount" class="def">offsetsCount</a> :: !<a href="Kafka-Internal-Types.html#t:Count">Count</a></dt><dd class="doc"><p>Maximum number of offsets that will be retrieved.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Offsets" class="caption collapser" onclick="toggleSection('i:Offsets')">Instances</p><div id="section.i:Offsets" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka-Internal-Request.html#t:Offsets">Offsets</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka-Internal-Request.html#t:Offsets">Offsets</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka-Internal-Request.html#t:Offsets">Offsets</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:putOffsetsRequest" class="def">putOffsetsRequest</a> :: <a href="Kafka-Internal-Request.html#t:Offsets">Offsets</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html#t:Put">Put</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L146" class="link">Source</a></p><div class="doc"><p><code>Put</code>s the given <code>Offsets</code> request.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>