<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Kafka</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Kafka.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka.hs">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">kafka-client-0.7.0.0: Low-level Haskell client library for Apache Kafka 0.7.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Abhinav Gupta 2015</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>mail@abhinavg.net</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Kafka</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Main interface</a></li><li><a href="#g:2">Types</a></li><li><a href="#g:3">Other</a></li><li><a href="#g:4">Transport</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A library to interact with Apache Kafka 0.7.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:withConnection">withConnection</a> ::  <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="Kafka.html#t:Socket">Socket</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a</li><li class="src short"><a href="#v:produce">produce</a> :: <a href="Kafka.html#t:Transport">Transport</a> t =&gt; t -&gt; [<a href="Kafka.html#t:Produce">Produce</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:fetch">fetch</a> :: <a href="Kafka.html#t:Transport">Transport</a> t =&gt; t -&gt; [<a href="Kafka.html#t:Fetch">Fetch</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> (<a href="Kafka.html#t:Response">Response</a> [<a href="Kafka.html#t:FetchResponse">FetchResponse</a>])</li><li class="src short"><a href="#v:offsets">offsets</a> :: <a href="Kafka.html#t:Transport">Transport</a> t =&gt; t -&gt; <a href="Kafka.html#t:Offsets">Offsets</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> (<a href="Kafka.html#t:Response">Response</a> [<a href="Kafka.html#t:Offset">Offset</a>])</li><li class="src short"><span class="keyword">data</span> <a href="#t:Produce">Produce</a> = <a href="#v:Produce">Produce</a> {<ul class="subs"><li><a href="#v:produceTopic">produceTopic</a> :: !<a href="Kafka.html#t:Topic">Topic</a></li><li><a href="#v:producePartition">producePartition</a> :: !<a href="Kafka.html#t:Partition">Partition</a></li><li><a href="#v:produceMessages">produceMessages</a> :: [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:Fetch">Fetch</a> = <a href="#v:Fetch">Fetch</a> {<ul class="subs"><li><a href="#v:fetchTopic">fetchTopic</a> :: !<a href="Kafka.html#t:Topic">Topic</a></li><li><a href="#v:fetchPartition">fetchPartition</a> :: !<a href="Kafka.html#t:Partition">Partition</a></li><li><a href="#v:fetchOffset">fetchOffset</a> :: !<a href="Kafka.html#t:Offset">Offset</a></li><li><a href="#v:fetchSize">fetchSize</a> :: !<a href="Kafka.html#t:Size">Size</a></li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:FetchResponse">FetchResponse</a> = <a href="#v:FetchResponse">FetchResponse</a> {<ul class="subs"><li><a href="#v:fetchMessages">fetchMessages</a> :: [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</li><li><a href="#v:fetchNewOffset">fetchNewOffset</a> :: !<a href="Kafka.html#t:Offset">Offset</a></li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:Offsets">Offsets</a> = <a href="#v:Offsets">Offsets</a> {<ul class="subs"><li><a href="#v:offsetsTopic">offsetsTopic</a> :: !<a href="Kafka.html#t:Topic">Topic</a></li><li><a href="#v:offsetsPartition">offsetsPartition</a> :: !<a href="Kafka.html#t:Partition">Partition</a></li><li><a href="#v:offsetsTime">offsetsTime</a> :: !<a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></li><li><a href="#v:offsetsCount">offsetsCount</a> :: !<a href="Kafka.html#t:Count">Count</a></li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:OffsetsTime">OffsetsTime</a><ul class="subs"><li>= <a href="#v:OffsetsLatest">OffsetsLatest</a></li><li>| <a href="#v:OffsetsEarliest">OffsetsEarliest</a></li><li>| <a href="#v:OffsetsBefore">OffsetsBefore</a> !<a href="http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime">UTCTime</a></li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Topic">Topic</a> = <a href="#v:Topic">Topic</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Offset">Offset</a> = <a href="#v:Offset">Offset</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word64">Word64</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Partition">Partition</a> = <a href="#v:Partition">Partition</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word32">Word32</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Size">Size</a> = <a href="#v:Size">Size</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word32">Word32</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Count">Count</a> = <a href="#v:Count">Count</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word32">Word32</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Error">Error</a><ul class="subs"><li>= <a href="#v:UnknownError">UnknownError</a></li><li>| <a href="#v:OffsetOutOfRangeError">OffsetOutOfRangeError</a></li><li>| <a href="#v:InvalidMessageError">InvalidMessageError</a></li><li>| <a href="#v:WrongPartitionError">WrongPartitionError</a></li><li>| <a href="#v:InvalidFetchSizeError">InvalidFetchSizeError</a></li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Response">Response</a> a = <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> <a href="Kafka.html#t:Error">Error</a> a</li><li class="src short"><span class="keyword">data</span> <a href="#t:Socket">Socket</a> :: *</li><li class="src short"><span class="keyword">class</span> <a href="#t:Transport">Transport</a> t <span class="keyword">where</span><ul class="subs"><li><a href="#v:send">send</a> :: t -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> ()</li><li><a href="#v:recv">recv</a> :: t -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li></ul></li></ul></div><div id="interface"><h1 id="g:1">Main interface</h1><div class="doc"><p>Requests to Kafka can be made using <code><a href="Kafka.html#v:produce">produce</a></code>, <code><a href="Kafka.html#v:fetch">fetch</a></code>, and
 <code><a href="Kafka.html#v:offsets">offsets</a></code>.  For <code><a href="Kafka.html#v:produce">produce</a></code> and <code><a href="Kafka.html#v:fetch">fetch</a></code>, the functions automatically
 decide whether the request needs to be a single <code>Produce</code>/<code>Fetch</code>
 request or a <code>Multi*</code> request.</p><p>The request operations send requests and receive responses using any
 type that is an instance of <code><a href="Kafka.html#t:Transport">Transport</a></code>. <code><a href="Kafka.html#v:withConnection">withConnection</a></code> produces one
 such object.</p></div><div class="top"><p class="src"><a name="v:withConnection" class="def">withConnection</a> ::  <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="Kafka.html#t:Socket">Socket</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Transport.hs#L87" class="link">Source</a></p><div class="doc"><p>Open a connection, execute the given operation on it, and ensure it is
 closed afterwards even if an exception was thrown.</p><pre>withConnection &quot;localhost&quot; 9092 $ \conn -&gt;
   doStuff conn
   fail &quot;something went wrong&quot;</pre><p>Throws an <code>IOException</code> if we were unable to open the connection.</p></div></div><div class="top"><p class="src"><a name="v:produce" class="def">produce</a> :: <a href="Kafka.html#t:Transport">Transport</a> t =&gt; t -&gt; [<a href="Kafka.html#t:Produce">Produce</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> () <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka.hs#L106" class="link">Source</a></p><div class="doc"><p>Sends the given <code><a href="Kafka.html#t:Produce">Produce</a></code> requests to Kafka.</p><p>If multiple requests are supplied, a <code>MultiProduce</code> request is made.</p><pre><code><a href="Kafka.html#v:withConnection">withConnection</a></code> &quot;localhost&quot; 9092 $ \conn -&gt;
  produce conn [
     <code><a href="Kafka.html#t:Produce">Produce</a></code> (<code><a href="Kafka.html#t:Topic">Topic</a></code> &quot;my-topic&quot;) (<code><a href="Kafka.html#t:Partition">Partition</a></code> 0) [&quot;foo&quot;]
   , Produce &quot;another-topic&quot; 0
               [&quot;multiple&quot;, &quot;messages&quot;]
   ]
</pre><p>Note that string literals may be used in place of <code><a href="Kafka.html#t:Topic">Topic</a></code> (with the
 <code>OverloadedStrings</code> GHC extension), and integer literals may be used in
 place of <code><a href="Kafka.html#t:Partition">Partition</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:fetch" class="def">fetch</a> :: <a href="Kafka.html#t:Transport">Transport</a> t =&gt; t -&gt; [<a href="Kafka.html#t:Fetch">Fetch</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> (<a href="Kafka.html#t:Response">Response</a> [<a href="Kafka.html#t:FetchResponse">FetchResponse</a>]) <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka.hs#L138" class="link">Source</a></p><div class="doc"><p><code><a href="Kafka.html#t:Fetch">Fetch</a></code>es messages from Kafka.</p><p>If multiple Fetch requests are supplied, a <code>MultiFetch</code> request is made.</p><pre><code><a href="Kafka.html#v:withConnection">withConnection</a></code> &quot;localhost&quot; 9092 $ \conn -&gt; do
  Right [<code><a href="Kafka.html#t:FetchResponse">FetchResponse</a></code> messages newOffset] &lt;- fetch conn [
      <code><a href="Kafka.html#t:Fetch">Fetch</a></code> (<code><a href="Kafka.html#t:Topic">Topic</a></code> &quot;test-topic&quot;) (<code><a href="Kafka.html#t:Partition">Partition</a></code> 0) (Offset 42) 1024
    ]
  {- Consume the messages here -}
  response &lt;- fetch conn [<code><a href="Kafka.html#t:Fetch">Fetch</a></code> &quot;test-topic&quot; 0 newOffset 1024]
  {- ... -}
</pre><p>Returns a list of <code><a href="Kafka.html#t:FetchResponse">FetchResponse</a></code>s in the same order as the <code><a href="Kafka.html#t:Fetch">Fetch</a></code>
 requests. Each response contains the messages returned for the
 corresponding request and the new offset at which the next request should
 be made for that request to get the messages that follow.</p><p>If a response for a request contains no messages, the specified
 topic-partition pair has been exhausted.</p><p>Note that string literals may be used in place of <code><a href="Kafka.html#t:Topic">Topic</a></code> (with the
 <code>OverloadedStrings</code> GHC extension), and integer literals may be used in
 place of <code><a href="Kafka.html#t:Offset">Offset</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:offsets" class="def">offsets</a> :: <a href="Kafka.html#t:Transport">Transport</a> t =&gt; t -&gt; <a href="Kafka.html#t:Offsets">Offsets</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> (<a href="Kafka.html#t:Response">Response</a> [<a href="Kafka.html#t:Offset">Offset</a>]) <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka.hs#L160" class="link">Source</a></p><div class="doc"><p>Retrieve message offsets from Kafka.</p><pre><code><a href="Kafka.html#v:withConnection">withConnection</a></code> &quot;localhost&quot; 9092 $ \conn -&gt; do
  Right [os] &lt;- offsets conn (Offsets &quot;topic&quot; 0 OffsetsEarliest 1)
  fetch conn [<code><a href="Kafka.html#t:Fetch">Fetch</a></code> &quot;topic&quot; (Partition 0) os 10] &gt;&gt;= doSomething
</pre><p>Note that string literals may be used in place of <code><a href="Kafka.html#t:Topic">Topic</a></code> (with the
 <code>OverloadedStrings</code> GHC extension), and integer literals may be used in
 place of <code><a href="Kafka.html#t:Count">Count</a></code>.</p></div></div><h1 id="g:2">Types</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Produce" class="def">Produce</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L53" class="link">Source</a></p><div class="doc"><p>A request to send messages down a Kafka topic-partition pair.</p><p>Produce requests do not have a corresponding response. There is no way of
 knowing in Kafka 0.7 if a message was successfully <code>Produce</code>d.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Produce" class="def">Produce</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:produceTopic" class="def">produceTopic</a> :: !<a href="Kafka.html#t:Topic">Topic</a></dt><dd class="doc"><p>Kafka topic to which the messages will be sent.</p></dd><dt class="src"><a name="v:producePartition" class="def">producePartition</a> :: !<a href="Kafka.html#t:Partition">Partition</a></dt><dd class="doc"><p>Partition of the topic.</p></dd><dt class="src"><a name="v:produceMessages" class="def">produceMessages</a> :: [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</dt><dd class="doc"><p>List of message payloads.</p><p>For those concerned with low-leveld details: These messages will be
 compressed using <a href="https://code.google.com/p/snappy/">Snappy</a> compression.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Produce" class="caption collapser" onclick="toggleSection('i:Produce')">Instances</p><div id="section.i:Produce" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Produce">Produce</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Produce">Produce</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Produce">Produce</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Fetch" class="def">Fetch</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L85" class="link">Source</a></p><div class="doc"><p>A request to fetch messages from a particular Kafka topic-partition pair.</p><p><code><a href="Kafka.html#t:FetchResponse">FetchResponse</a></code> contains responses for this kind of request.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fetch" class="def">Fetch</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:fetchTopic" class="def">fetchTopic</a> :: !<a href="Kafka.html#t:Topic">Topic</a></dt><dd class="doc"><p>Kafka topic from which messages will be fetched.</p></dd><dt class="src"><a name="v:fetchPartition" class="def">fetchPartition</a> :: !<a href="Kafka.html#t:Partition">Partition</a></dt><dd class="doc"><p>Partition of the topic.</p></dd><dt class="src"><a name="v:fetchOffset" class="def">fetchOffset</a> :: !<a href="Kafka.html#t:Offset">Offset</a></dt><dd class="doc"><p>Offset at which the fetch will start.</p><p>Kafka offloads the responsiblity of knowing this to the client. That
 means that if an offset is specified here that is not a real message
 start, Kafka will spit out garbage.</p><p>Use <code><a href="Kafka.html#v:offsets">offsets</a></code> to find valid offsets.</p></dd><dt class="src"><a name="v:fetchSize" class="def">fetchSize</a> :: !<a href="Kafka.html#t:Size">Size</a></dt><dd class="doc"><p>Maximum size of the returned messages.</p><p>Note, this is <em>not</em> the number of messages. This is the maximum
 combined size of the returned <em>compressed</em> messages.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Fetch" class="caption collapser" onclick="toggleSection('i:Fetch')">Instances</p><div id="section.i:Fetch" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Fetch">Fetch</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Fetch">Fetch</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Fetch">Fetch</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:FetchResponse" class="def">FetchResponse</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Response.hs#L24" class="link">Source</a></p><div class="doc"><p>Result of a single Kafka <code><a href="Kafka.html#t:Fetch">Fetch</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:FetchResponse" class="def">FetchResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:fetchMessages" class="def">fetchMessages</a> :: [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</dt><dd class="doc"><p>List of messages returned in the response for the <code><a href="Kafka.html#t:Fetch">Fetch</a></code>
 request.</p></dd><dt class="src"><a name="v:fetchNewOffset" class="def">fetchNewOffset</a> :: !<a href="Kafka.html#t:Offset">Offset</a></dt><dd class="doc"><p>New offset at which the next <code><a href="Kafka.html#t:Fetch">Fetch</a></code> request should start reading in
 the same topic and partition to access the messages that follow the
 messages returned in this response.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:FetchResponse" class="caption collapser" onclick="toggleSection('i:FetchResponse')">Instances</p><div id="section.i:FetchResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:FetchResponse">FetchResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:FetchResponse">FetchResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:FetchResponse">FetchResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Offsets" class="def">Offsets</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Request.hs#L125" class="link">Source</a></p><div class="doc"><p>A request to retrieve offset information from Kafka.</p><p>The response for this kind of request is a list of <code><a href="Kafka.html#t:Offset">Offset</a></code>s.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Offsets" class="def">Offsets</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:offsetsTopic" class="def">offsetsTopic</a> :: !<a href="Kafka.html#t:Topic">Topic</a></dt><dd class="doc"><p>Kafka topic from which offsets will be retrieved.</p></dd><dt class="src"><a name="v:offsetsPartition" class="def">offsetsPartition</a> :: !<a href="Kafka.html#t:Partition">Partition</a></dt><dd class="doc"><p>Partition of the topic.</p></dd><dt class="src"><a name="v:offsetsTime" class="def">offsetsTime</a> :: !<a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></dt><dd class="doc"><p>Time around which offsets will be retrieved.</p><p>If you provide a time for this, keep in mind that the response will not
 contain the precise offset that occurred around that time. It will return
 up to <code>offsetsCount</code> offsets in descending, each being the first offset
 of every segment file for the specified partition with a modified time
 less than the specified time, and possibly a &quot;high water mark&quot; for the
 last segment of the partition (if it was modified before the specified
 time) which specifies the offset at which the next message to that
 partition will be written.</p></dd><dt class="src"><a name="v:offsetsCount" class="def">offsetsCount</a> :: !<a href="Kafka.html#t:Count">Count</a></dt><dd class="doc"><p>Maximum number of offsets that will be retrieved.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Offsets" class="caption collapser" onclick="toggleSection('i:Offsets')">Instances</p><div id="section.i:Offsets" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Offsets">Offsets</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Offsets">Offsets</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Offsets">Offsets</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:OffsetsTime" class="def">OffsetsTime</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L101" class="link">Source</a></p><div class="doc"><p>Different times for which offsets may be retrieved using
 <code><a href="Kafka.html#v:offsets">offsets</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:OffsetsLatest" class="def">OffsetsLatest</a></td><td class="doc"><p>Retrieve the latest offsets</p></td></tr><tr><td class="src"><a name="v:OffsetsEarliest" class="def">OffsetsEarliest</a></td><td class="doc"><p>Retrieve the earliest offsets.</p></td></tr><tr><td class="src"><a name="v:OffsetsBefore" class="def">OffsetsBefore</a> !<a href="http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime">UTCTime</a></td><td class="doc"><p>Retrieve offsets before the given time.</p><p>Keep in mind that the response will not contain the precise offset that
 occurred around this time. It will return up to the specified count of
 offsets in descending, each being the first offset of every segment
 file for the specified partition with a modified time less than this
 time, and possibly a &quot;high water mark&quot; for the last segment of the
 partition (if it was modified before this time) which specifies the
 offset at which the next message to that partition will be written.</p></td></tr></table></div><div class="subs instances"><p id="control.i:OffsetsTime" class="caption collapser" onclick="toggleSection('i:OffsetsTime')">Instances</p><div id="section.i:OffsetsTime" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> <a href="Kafka.html#t:OffsetsTime">OffsetsTime</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Topic" class="def">Topic</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L161" class="link">Source</a></p><div class="doc"><p>Represents a Kafka topic.</p><p>This is an instance of <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:IsString">IsString</a></code> so a literal string may be used to create
 a Topic with the <code>OverloadedStrings</code> extension.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Topic" class="def">Topic</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Topic" class="caption collapser" onclick="toggleSection('i:Topic')">Instances</p><div id="section.i:Topic" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Topic">Topic</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:Topic">Topic</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Topic">Topic</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Topic">Topic</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:IsString">IsString</a> <a href="Kafka.html#t:Topic">Topic</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> <a href="Kafka.html#t:Topic">Topic</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Offset" class="def">Offset</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L176" class="link">Source</a></p><div class="doc"><p>Represents an Offset in Kafka.</p><p>This is an instance of <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a></code> so a literal number may be used to create an
 Offset.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Offset" class="def">Offset</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word64">Word64</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Offset" class="caption collapser" onclick="toggleSection('i:Offset')">Instances</p><div id="section.i:Offset" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Offset">Offset</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a> <a href="Kafka.html#t:Offset">Offset</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:Offset">Offset</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Offset">Offset</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Offset">Offset</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> <a href="Kafka.html#t:Offset">Offset</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Partition" class="def">Partition</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L187" class="link">Source</a></p><div class="doc"><p>Represents a Kafka topic partition.</p><p>This is an instance of <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a></code> so a literal number may be used to create a
 Partition.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Partition" class="def">Partition</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word32">Word32</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Partition" class="caption collapser" onclick="toggleSection('i:Partition')">Instances</p><div id="section.i:Partition" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Partition">Partition</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a> <a href="Kafka.html#t:Partition">Partition</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:Partition">Partition</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Partition">Partition</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Partition">Partition</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> <a href="Kafka.html#t:Partition">Partition</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Size" class="def">Size</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L198" class="link">Source</a></p><div class="doc"><p>Represents a size.</p><p>This is an instance of <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a></code> so a literal number may be used to create a
 Size.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Size" class="def">Size</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word32">Word32</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Size" class="caption collapser" onclick="toggleSection('i:Size')">Instances</p><div id="section.i:Size" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Size">Size</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a> <a href="Kafka.html#t:Size">Size</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:Size">Size</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Size">Size</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Size">Size</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> <a href="Kafka.html#t:Size">Size</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Count" class="def">Count</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L209" class="link">Source</a></p><div class="doc"><p>Represents a Count.</p><p>This is an instance of <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a></code> so a literal number may be used to create a
 Size.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Count" class="def">Count</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html#t:Word32">Word32</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Count" class="caption collapser" onclick="toggleSection('i:Count')">Instances</p><div id="section.i:Count" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Count">Count</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num">Num</a> <a href="Kafka.html#t:Count">Count</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:Count">Count</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Count">Count</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Count">Count</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> <a href="Kafka.html#t:Count">Count</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Other</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Error" class="def">Error</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Types.hs#L38" class="link">Source</a></p><div class="doc"><p>Different errors returned by Kafka.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:UnknownError" class="def">UnknownError</a></td><td class="doc"><p>Unknown error</p></td></tr><tr><td class="src"><a name="v:OffsetOutOfRangeError" class="def">OffsetOutOfRangeError</a></td><td class="doc"><p>Offset requested is invalid or no longer available on the server.</p></td></tr><tr><td class="src"><a name="v:InvalidMessageError" class="def">InvalidMessageError</a></td><td class="doc"><p>A message failed to match its checksum.</p></td></tr><tr><td class="src"><a name="v:WrongPartitionError" class="def">WrongPartitionError</a></td><td class="doc"><p>The requested partition doesn't exist.</p></td></tr><tr><td class="src"><a name="v:InvalidFetchSizeError" class="def">InvalidFetchSizeError</a></td><td class="doc"><p>The maximum size requested for fetching is smaller than the message
 being fetched.</p></td></tr></table></div><div class="subs instances"><p id="control.i:Error" class="caption collapser" onclick="toggleSection('i:Error')">Instances</p><div id="section.i:Error" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Error">Error</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Kafka.html#t:Error">Error</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Kafka.html#t:Error">Error</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Error">Error</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize.html#t:Serialize">Serialize</a> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Kafka.html#t:Error">Error</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Response" class="def">Response</a> a = <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> <a href="Kafka.html#t:Error">Error</a> a <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Response.hs#L21" class="link">Source</a></p><div class="doc"><p>A response from Kafka can either be a failure or the value that was
 expected.</p></div></div><h1 id="g:4">Transport</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Socket" class="def">Socket</a> :: *</p><div class="subs instances"><p id="control.i:Socket" class="caption collapser" onclick="toggleSection('i:Socket')">Instances</p><div id="section.i:Socket" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Kafka.html#t:Socket">Socket</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Kafka.html#t:Socket">Socket</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Kafka.html#t:Transport">Transport</a> <a href="Kafka.html#t:Socket">Socket</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> * <a href="Kafka.html#t:Socket">Socket</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Transport" class="def">Transport</a> t <span class="keyword">where</span> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Transport.hs#L24" class="link">Source</a></p><div class="doc"><p>Types that provide a means to send and receive bytes.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:send" class="def">send</a> :: t -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> () <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Transport.hs#L24" class="link">Source</a></p><div class="doc"><p>Send the given ByteString down the transport.</p><p>This must block until the request has been finished.</p></div><p class="src"><a name="v:recv" class="def">recv</a> :: t -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="https://github.com/abhinav/haskell-kafka-client/tree/master/Kafka/Internal/Transport.hs#L24" class="link">Source</a></p><div class="doc"><p>Read up to the given number of bytes from the stream.</p><p>The returned ByteString may be empty if the end of the stream was
 reached.</p></div></div><div class="subs instances"><p id="control.i:Transport" class="caption collapser" onclick="toggleSection('i:Transport')">Instances</p><div id="section.i:Transport" class="show"><table><tr><td class="src"><a href="Kafka.html#t:Transport">Transport</a> <a href="Kafka.html#t:Socket">Socket</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>